<?xml version="1.0" encoding="utf-8"?>
<!DOCYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="nl" lang="nl">
  <head>
    <title>CS 179n, Spring 2018</title>
    <style type="text/css">
      .homeworktable, th, td, .lecturetable, .labtable, .grading {border: 1px solid black; border-collapse: collapse;}
      th, td {padding: 5px; text-align: center;}
      .lecturetable td:nth-of-type(4) {text-align: left;}
      .homeworktable td:nth-of-type(5) {text-align: left;}
      .grading td:nth-of-type(1) {text-align: left;}
      .grading td:nth-of-type(2) {text-align: left;}
      .hwr, .hwr td {padding:0px;height:1px;background-color:black;}
      .hwd td:nth-of-type(1) {display:none;}
    </style>
  </head>
  <body>

    <h1>Project</h1>

    <h2>Team assignments</h2>
    
    <p>
      Projects must be completed in teams of <b>3-5</b> members.
      Each team will select one member to be the team leader.
      Each team must complete <b>one</b> of the project options listed below.
      This project is broken into a number of smaller pieces: a proposal, five milestones, the final project submission, and a presentation.
      Each of these should be completed as a team but submitted only by the team leader (except for the presentation, which is shared by the entire team).
    </p>
    
    <p>
      The first lab (04/03) will provide an opportunity to form teams, if you have not already done so.
      By Friday (04/06), each <b>team leader</b> must submit the names of all members of his/her team on iLearn.
      Decide as a team which of the three project options you would like to pursue; the team leader will note this along with the list of team members.
    </p>
    
    <h2>Proposals</h2>

    <p>
      Each team will prepare a proposal, which the team leader will upload on iLearn.
      Each proposal must specify in detail what the team will do, what will be accomplished and submitted at each of the five milestones, and what functionality will be demonstrated at the final presentation or in the final submission.
      Each project must meet the general requirements outlined below as well as the requirements specific to the chosen project option.
    </p>

    <p>
      Please exercise a combination of ambition and restraint when writing your proposals.
      For many students, this class will be your last opportunity to produce a major product and impress a potential future employer.
      If done well, all three project options will lead to a visually appealing and interesting result.
      On the other hand, be realistic about what you can accomplish given the size of your team and the time available.
      Please note that it is okay to take some risk here.
      It is possible to recieve good scores for your project even if your proposal ended up being a bit too ambitious, provided reasonable effort was applied towards achieving that goal.
      You may distinguish between primary and secondary objectives in your proposal, distinguishing between what you are sure you can accomplish and what you would like to accomplish in addition to that.
    </p>

    <h2>Common project requirements</h2>

    <p>
      Each project must meet the following requirements
      <ul>
        <li>
          Each team will be responsible for setting up a <b>private</b> git repository for their project.
          You may use github or bitbucket if you choose, but your repositories must be visible to all members of your team and <b>nobody else</b>.
          You will submit a copy of your git repository as part of your final submission.
          It is important to make sure that all team members are able to push changes to this repository (using their own name), as this will be used to help assess team member contributions to the project.
        </li>
        <li>
          Proposals, checkpoints (if appropriate), and final project writeups must be written in LaTeX.
          Note that LaTeX is plain text, which means it can be written collaboratively with all of the the benifits of version control just as programming source code can be.
          You should compose these documents in the same git repository as the rest of your project.
        </li>
        <li>
          The tasks of the project should be divided into six roughly even pieces.
          The first five will be submitted as milestones both as proof of progress and to encourage steady progress towards project goals.
          It is recommended to assign slightly larger portions of the project for earlier milestones, since students tend to get bogged down with commitments from other courses towards the end of the quarter.
        </li>
        <li>
          Each team leader must submit proof of progress for each milestone.
          The proposal must clearly state (1) what will be accomplished by each milestone, (2) what will be submitted as proof that that milestone was achieved, and (3) what if anything was not achieved and why.
          What makes sense as a proof of progress depends on the project; I give some suggestions for each project below.
          Proposals that do not provide reasonable division of tasks into milestones or adequate proof for completion of the milestones will be returned for revision.
        </li>
        <li>
          Milestones are a great opportunity to reflect on your team's progress towards achieving your goals.
          Are you falling behind?
          If so, what plan do you have to catch up?
          Is the current strategy for splitting up work among team members working well?
          If not, what plan do you have to improve it?
        </li>
      </ul>
    </p>

    <h2>Project options</h2>

    <h3>Option 1: Game</h3>

    <p>
      Write a computer game.
      The game may be 2D or 3D.
      The narrative of the game must be original; the objective is not to produce a clone or variation of an existing game.
    </p>

    <p>
      You may use an <b>open source</b> game engine for this project.
      You may find a list of game engines and their licenses <a href="https://en.wikipedia.org/wiki/List_of_game_engines">here</a>.
      You may also use <b>open source</b> tools for modelling and creating game assets.
      We recommend using blender for both tasks; we will provide limited assistance to teams using this tool.
      We will also introduce its use during two of the labs.
      You are not restricted to using blender, but we will not be able to assist you with the use of other tools.
      If you would like to use an alternative tool, please state this in your proposal.
      We will try to make these tools available in WCH 133 so that you can use them when you work on your projects during labs.
      Note that the restriction on commercial tools applies to artistic tools only (Unity game engine, Maya, Houdini, etc.).
      There is no restriction on the use of commercial tools for other purposes (Microsoft Office, Keynote, Visual Studio, XCode, Sublime Text, Matlab, etc.)
    </p>

    <p>
      Each team must make their <b>own</b> assets, including geometry, scenery, characters, etc.
      You may not receive assistance from anyone outside your team (for example, if you have a friend who is an artist, they may not produce artwork for your game).
      You may not purchase or download any assets for your game.
      The one exception to this is music.
      You may download music for your game, subject to the following restrictions:
      <ul>
        <li>It <b>must</b> have a license compatible with its use in this game.  For example, music under a creative commons license or in the public domain are acceptable.</li>
        <li>You <b>must</b> use the music in accordance with that license, including any attribution requirements.</li>
        <li>You <b>must</b> provide a link to the <b>source</b> of that music and to the <b>license</b> under which that music is available.</li>
        <li>If you are not sure if your are allowed to use it, <b>ask</b>.  Don't guess.</li>
        <li>If you created the music yourself, document this.  Take a picture.  Submit the score.</li>
      </ul>
      No commercial assets or music are permitted, and there is zero tolerance for violation of copyright.
    </p>

    <p>
      There is no language restriction for this project option.
      The language(s) you use will largely be dictated by your choice of game engine.
    </p>

    <p>
      Your first milestone must contain a complete plan for your game, which you must submit for this milestone.
      This should contain (1) the story line and objective for the game, (2) a list of all of the characters in your game, (3) all of the actions that your characters will be able to perform, (4) all of the interactions that can occur between your characters, and (5) all of the interactions that can occur between your characters and the world.
      If some of your characters will have AI, explain how those characters will behave.
      Your proposal should contain a sketch of this information, and it should be detailed enough that you can choose reasonable milestones.
      The information submitted for the first milestone must be essentially exhaustive.
      If you are unable to plan out all of the characters and interactions in a week, you will probably not be able to implement all of them in a quarter.
      Note that you do not need to provide sketches for the characters at this stage.
    </p>

    <p>
      The other milestones are up to you.
      For example, if your milestone is to have completed the geometry for each of your characters, then you might submit screenshots of the geometry you have produced.
      If your milestone is to have the navigation controls and a subset of game interactions working, submit a video recording of a team member playing the game and demonstrating that those interactions work.
    </p>

    <p>
      You must demonstrate your completed game during your final presentation.
      Please test it carefully before you present, as per Murphy's law.
    </p>

    <h3>Option 2: Ray Tracing</h3>

    <p>
      For ray tracing project, you will produce a functional and practically useful ray tracer.
      The ray tracers you wrote in CS 130 lack many basic features, such as the ability to render triangulated geometry or apply texture maps.
      In this project, you will implement those features.
      You may use code that one or more of your team members wrote in CS 130/230 as a starting point for this project; you should document where this code came from.
    </p>

    <p>
      At a minimum, your final ray tracer must support the following features
      <ul>
        <li>Support for triangle meshes, spheres, planes, and boxes</li>
        <li>Support for at least one of these: cylinders, tori, cones</li>
        <li>Support for point lights, area lights, and antialiasing</li>
        <li>Acceleration structures to optimized the performance of ray intersections.</li>
        <li>Reflection, transmission, phong shading, texture mapping</li>
        <li>Transformations (the ability to translate, rotate, and scale objects in your scene)</li>
        <li>Booleans (union, intersection, difference)</li>
        <li>Your own scene language which will allow you to exercise all of these features.  You may build on the format from CS 130/230 if you choose.</li>
        <li>At least two additional features of your choosing</li>
      </ul>
      All ray tracers must be written in C or C++, and they must compile and run on the Linux machines in WCH 133.
    </p>

    <p>
      A reasonable way to break up milestones for this project is to list out the features you plan to implement and divide them into six sets.
      You may submit renders demonstrating that the required functionality works to show that you have completed the objectives for each milestone.
      If you see artifacts in your results, this is also a good opportunity to submit these and get feedback on what might be causing them.
    </p>

    <p>
      Although there are no particular requirements on the order you plan things, I recommend doing the acceleration structure early.
      Without it, renders may become painfully slow.
      It will be helpful if you are able to disable the acceleration structure for testing purposes, since it is very common for bugs to exist in these routines.
    </p>
    
    <h3>Option 3: Fluid simulation</h3>

    <p>
      Write a fluid simulator.
      You may simulate smoke, water, or fire.
      As a general rule, smoke is easier, but water and fire are more impressive.
      Water is probably the most difficult.
      The fluid simulator is more math-intensive than the other two project options.
    </p>

    <p>
      You should implement splitting for the fluids.  The simulation should be
      Eulerian (fixed regular grid).  That means you will need to implement:
      <ul>
        <li>Advection (second order Semi-Lagrangian Advection or MacCormack method are fine, but not Semi-Lagrangian Advection)</li>
        <li>Pressure projection (central difference is easiest and works well)</li>
        <li>If doing water, the level set method for tracking the water surface</li>
      </ul>
      For simplicity, you do not need to implement:
      <ul>
        <li>Viscosity</li>
        <li>Surface tension</li>
      </ul>
      Your simulator must be written in C or C++, and they must compile and run on the Linux machines in WCH 133.
    </p>

    <p>
      
    </p>
</p>
    
  </body>
</html>

